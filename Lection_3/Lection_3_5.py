"""
Лекция 3.5.
Разработка декораторов
"""

"""
def div(x, y):
    try:
        return x/y
    except ZeroDivisionError:
        return None
"""

# если исключение находится внутри большой функции и не понятно где искать ошибку, можно применить декоратор
# декоратор - это функция, которая оборачивает другую функцию и добавляет дополнительные свойства к ней

# обработчик деления на 0
# внутри декоратора обязательно нужно объявить функцию, кот принимает (*args, **kwargs), те принимает любые аргументы
def zero_div_handler_decorator(func):
    def wrapper(*args, **kwargs):
        x, y = args
        if y == 0:
            return None
        return func(*args, **kwargs)  # вызываем оригинальную функцию c теми же параметрами
    return wrapper  # при вызове декоратора появляется новая функция с новой логикой, внутри которой вызывается оригинальная функция, но уже без ошибок


# decorated_div = zero_div_handler_decorator(div)  #результат работы декоратора, он уже не должен вызывать ошибку
# print(decorated_div(4, 2))
# print(decorated_div(4, 0))


# улучшим способ привязки декоратора к существующей функции

@zero_div_handler_decorator
def div(x, y):
    return x/y

# теперь вызов функции div будет безошибочным
print(div(4, 2))
print(div(4, 0))

# так же сами декораторы и @декоратор могут иметь параметры