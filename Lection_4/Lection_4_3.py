"""
Лекция 4.3.
“Ленивые” вычисления.
Разработка генераторов
"""

# те объекты, которые можно перебрать в цикле называются итераторами, они хранятся в памяти
# у них есть метод next, который переходит к следующему значению и текущее значение, кот выводится сейчас

# mylist = [x*x for x in range(3)] - создание списка с помощью генераторного выражения
# генераторы - тоже итераторы, но их можно прочитать только 1 раз, тк они не хранят значения в памяти, а генерируют их на лету
# генераторы хранят внутри некоторое состояние и знают как перевести это состояние на следующий уровень
# генератор квадратов
def my_generator():
    print("старт генератора")
    i = 1   # начальное значение
    while True:
        print('итерация генератора', i)
        i += 1
        yield i ** 2  # возведение в квадрат
        # с помощью оператора yield берем и возвращаем это значение дальше, а в дальнейшем эта функция будет продолжать работать
# Yield это ключевое слово, которое используется примерно как return — отличие в том, что функция вернёт генератор.

# нельзя применить конструкцию for i in mygenerator второй раз, так как генератор может быть использован только единожды: он вычисляет 0, потом забывает про него и вычисляет 1, и тд  — одно за другим.
# код будет вызываться каждый раз, когда for обращается к генератору.
# когда вы вызываете функцию, код внутри тела функции не исполняется. Функция только возвращает объект-генератор

# В первый запуск вашей функции, она будет исполняться от начала до того момента, когда она наткнётся на yield —
# тогда она вернёт первое значение из цикла. На каждый следующий вызов будет происходить ещё одна итерация написанного вами цикла,
# возвращаться будет следующее значение — и так пока значения не кончатся.

# Генератор считается пустым, как только при исполнении кода функции не встречается yield.
# Это может случиться из-за конца цикла, или же если не выполняется какое-то из условий «if/else».

for i in my_generator(): # в этом цикле происходит вызов функции
    print('в цикле', i)
    if i > 10:
        break  # прерывает цикл

# мы не храним внутри генератора какой-то список в памяти, он просто знает как перейти к следующему числу и что с ним делать
# их используют при обработке больших данных (списков), которые не влезают в память компа
# удобно, если вы знаете, что функция вернёт большой набор значений, который надо будет прочитать только один раз.

# более компактный вариант генератора с помощью ():
my_generator2 = (i ** 2 for i in range(100))
print(my_generator2)
print(list(my_generator2))
