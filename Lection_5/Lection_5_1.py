"""
Лекция 5.1.
Объявление класса: конструктор, поля объекта, методы.
Создание экземпляров классов (объектов).
Использование объектов
Лекция 5.2
Инкапсуляция
"""

"""
ООП позволяет перенести отношения реальных объектов в код
класс - чертеж нашего объекта, по кот будем созж
классы объединяют данные и действия одного рода
на базе класса можно создать объект (экземпляр)
мы можем боать какие-то его свойства, вызывать методы, изменять с помощью них свойства
"""

class Cat():
    # конструктор (__init__)- метод, кот будет автоматически вызываться при создании объекта класса
    # переменная self отвечает за ссылку на текущий объект,
    # чтобы что-то записать в объект мы должны к нему обратиться через self.

    # мы получили чертеж кота, который должен обладать след параметрами
    # заполняя эти параметры получаем конкретное представление кота и можеи с ним работать

    _count = 0
    # когда название свойства начинается с _ мы помечаем, что никто из вне к нему обращаться не будет
    # это соглашение python-разработки, к этому свойству можно обратиться из вне, но лучше не стоит
    # с можно работать либо внутри объекта/класса, либо с помощью метода get_count() из вне

    # инкапсуляция (_, __) позволяет управлять доступом к некот переменным и не давать доступ определ лицам
    # кладет переменную в капсулу и у нас есть только огранич возможности по доступу к ней
    # в питоне приватность не всегда реальная, свойсто все равно можно получ за границами объекта, но этого делать не стоит

    def __init__(self, name, weight, color):
        # свойства:
        # с помощью __ помечаем это свойство приватным
        # внутри этого класса образаемся к этой переменной тоже через __, а снаружи к ней доступа нет
        # непосредственно к нему можно обращаться только внутри объекта/класса
        # либо с помощью метода get_name() из вне
        self.__name = name
        self.weight = weight
        self.color = color
        self.fullness = 0
        Cat._count += 1

    # в объекте кроме данных, могут быть спец функции - методы для работы с ними
    def eat(self, fullness=1):
        print(f"{self.__name} поел")
        self.fullness += fullness

    # при работе с объектами в переменной хранится ссылка на объект
    # и когда мы его печатаем на экран возникает непонятная фаза
    # чтобы выводилась нормальная инфа об объекте переопределим метод
    # теперь при выводе объекта будет возвращаться значение этой функции
    def __str__(self):
        return f'Кот {self.__name}'

    # чтобы получить информацию о приватном свойстве вне скласса, создадим метод
    def get_name(self):
        return self.__name

    # чтобы иметь возможность изменить значение приватного поля из вне добавим функцию:
    def set_name(self, name):
        self.__name = name


    # статические методы вызываются без создания объекта
    # для этого к обычному методу добавляем декоратор статики
    # стат методы обычно исп для математических методов, тк математика всегда одна для всех
    @staticmethod
    def get_count():
        return Cat._count  # количество объектов этого класса



# создание объекта класса
vasya = Cat("Вася", 5, "black")
barsik = Cat("Барсик", 8, "ginger")

print(vasya)
vasya.set_name("Вася Великолепный")
print(vasya.get_name())
print(barsik)

# получение информации об объектах класса, которая записана у них внутри через .
# print(vasya.name, vasya.color)
# print(barsik.name, barsik.color, barsik.fullness)

barsik.eat()
barsik.eat(2)
barsik.eat(3)
print(barsik.fullness)

# при вызове статической функции обращаемся ко всему классу, а не к конкретному объекту
print(Cat.get_count())

