"""
Лекция 5.4.
Работа с исключениями
"""
import random

# SyntaxError - системная ошибка: в этом месте где-то есть синтаксическая ошибка
# это системная ошибка, ее нельзя отловить дебагом, так как она возникает до запуска программы
# код программы неправильный и поэтому она не может быть выполнена
# мы не можем отловить это исключение, те как-то узнать о нем и как-то на него отреагировать
# print("hello world"

# остальные исключения отловить можно:
dct = {"a": 1}
# print(dct['b'])
# KeyError: 'b' - такого ключа в словаре нет
# после появления исключения код дальше выполняться не будет
# так как возникла ошибка и программа была прервана
# чтобы программа не прерывалась и мы могли как-то реагировать на исключения, есть конструкция:

# эта конструкция ловит исключения
# и если какое-то определ исключ возникло, то обработка переходит в блок except
# где мы можем как-то отреагировать на исключение

try:
    print(dct['b'])
except KeyError as e:
    # когда мы ловим исключение, есть объект этого исключения - e и в нем есть различные параметры
    # этот объект при приведении к строке (выводе) будет описывать ту ошибку, кот возникла
    # здесь это ключ, кот не получилось извлечь из словаря
    print("ключа не существует", e)

try:
    number1 = int(input())
    number2 = int(input())
    print(number1/number2)
    # чтобы обработать конкретное исключение:
except (ZeroDivisionError, ValueError) as e:
    print("введены неправильные данные", e)
    # чтобы обработать остальные исключения:
except BaseException as e:    # самые базовые исключения в python
    print("произошла неизвестная ошибка:")
    print(e)
    print(type(e))

# если number2 = 0
# division by zero
# <class 'ZeroDivisionError'>

# если вместо натуральных чисел какие-то другие знач (строчки)
# invalid literal for int() with base 10: 'апр'
# <class 'ValueError'>
# было передано неправильное значение в функцию int()

print("111")

# рекомендуется в своих проектах создавать собственные исключения, кот наследуюстя от исключений питона Exception
# а конкретные исключения уже наследовать от исключения нашего приложения
# так будет проще понять когда возникло исключение связанное с нашим проектом (приложением), а когда с каким-то кодом в python

class AppException(Exception):
    pass

# собственный класс для исключений
class MyException(AppException):

    # в исключение можно добавить свои атрибуты:
    # message - сообщение об ошибке, obj - объект, кот виноват в это исключ и тд
    # затем во время отладки можно будет отлавливать эти параметры и что-то с ними делать
    def __int__(self, message):
        self.message = message

    def __str__(self):
        return self.message

# функция, кот в 50% случаев будет выкидывать исключение
def my_func():
    if random.random() > 0.5:
        raise MyException('test')

for i in range(10):
    print(i)
    my_func()


# появилось это сообщение, оно называется stacktraice
# оно сообщает где (на какой строчке кода) и какие исключения возникли
# эта информация поможет исправить ошибку и понять что было не так
"""
Traceback (most recent call last):
  File "D:\PycharmProjects\ORPUD\ORPUD_Python\ORPUD_Python_Lections\Lection_5\Lection_5_4.py", line 75, in <module>
    my_func()
  File "D:\PycharmProjects\ORPUD\ORPUD_Python\ORPUD_Python_Lections\Lection_5\Lection_5_4.py", line 71, in my_func
    raise MyException('test')
__main__.MyException: <exception str() failed>
"""

# тогда обработку исключений можно построить след образом:
for i in range(10):
    print(i)
    try:
        my_func()
    except MyException:  # самый низший класс в иерархии, здесь обработается только MyException, если он до этого не был пойман
        ... # 1 specific app exception
    except AppException: # здесь обработается AppException и его наследник MyException, если он до этого не был пойман
        ... # 2 other app exceptions
    except BaseException: # здесь обработаются все исключения, если они до этого не были пойманы
        ... # 3 python exceptions

# исключения стоит применять, когда в функции есть несколько ошибочных операций, кот могут возникнуть в ходе его выполнения
# можно обойтись без исключений, если функция выдает либо правильное значение, либо None
# так как просто по возвращаемому значению можно понять, что функция не смогла что-то выполнить верно и вернула None
# если более сложная операция, в ходе кот может возникнуть много проблем, можно использовать исключени
# и с помощью них уведомлять другие части кода
# при обработке исключений ловится само исключение и все его наследники
